{"meta":{"title":"ZzT's Blog","subtitle":"","description":"","author":"ZzT","url":"https://zzt.github.io","root":"/"},"pages":[],"posts":[{"title":"Windows 内存管理知识","slug":"windows-memory-management","date":"2022-09-30T03:28:35.000Z","updated":"2022-09-30T03:30:43.341Z","comments":true,"path":"2022/09/30/windows-memory-management/","link":"","permalink":"https://zzt.github.io/2022/09/30/windows-memory-management/","excerpt":"","text":"Windows 内存管理知识总结 工作中遇到了 32位 windows 程序虚拟内存不足的问题，于是对 Windows 内存相关知识做了调研探索。文内容总结自《Windows Internal》和 MSDN 文档，具体链接会注在文章最后，供大家参考 预备知识在了解 Windows 内存知识前，需要弄清「虚拟内存」和「物理内存」的关系 虚拟内存和物理内存的关系 首先，了解一下内存分配过程涉及到的一些概念： 进程分配的都是虚拟内存，不能直接使用物理内存 虚拟内存地址通过 MMU (Mememory Management Unit），会被翻译为物理地址，找到对应的物理页 分配连续的虚拟内存，对应的物理内存不一定是连续的，好处是在进程层面不用过多考虑内存碎片化的影响 页命中，物理内存中存在对应的物理页 缺页（paging fault）异常，物理内存中没有找到对应的物理页 交换（swapping）或页面调度（paging），将当前没用的物理页（牺牲页）写入磁盘，将需要用的虚拟内存页映射到物理内存页 总的来说，我们的程序用的都是虚拟内存，操作系统和硬件帮助我们将虚拟地址翻译为真正的物理地址，然后程序才能访问到内存中的数据。 比如图中所示，物理内存一共只有4页。开始时，「进程A」分配了 4 页内存，此时物理内存已经占满。此时如果「进程B」又分配了 2 页内存「VP3」「VP4」，这时会触发缺页异常，操作系统会根据缓存策略将短时间用不到的内存数据交换到磁盘，比如「进程A」的 「VP3」「VP4」被换出到磁盘。然后，「进程B」的「VP3」「VP4」才能被使用。 上面的例子只是帮助大家大致理解内存分配的流程，实际情况会更加复杂，涉及到缓存优化，空间优化等过程，本文不再赘述。 我们还可以观察到，图中的虚拟内存处在不同的状态，「Reserved」「Commited」，这两个状态代表了什么呢？请继续看下节。 Windows中虚拟内存的两种状态 reserved &amp; comitted reserved 预留，表示预先分配的虚拟内存，但还没有映射到物理内存，在使用时需要先命中物理页 commited 已经提交，表示虚拟内存已经映射到了物理内存或已经缓存在磁盘 commited pages 也是 private pages，表示不能与其他进程共享 为什么虚拟内存需要 reserved，而不是直接使用 commited？这是我在 stackoverflow 上找到的我比较认可的回答： Why would I want to reserve? Why not just get committed memory? There are several reasons I have in mind: Some application needs a specific address range, say from 0x400000 to 0x600000, but does not need the memory for storing anything. It is used to trap memory access. E.g., if some code accesses such area, it will be caught. (Useful for some reason.) Some thread needs to store progressively expanding data. And the data needs to be in one contiguous chunk of memory. It is preferred not to commit large physical memory at one go because it is not needed and would be such a waste. The memory can be utilized by some other threads first. The physical memory is committed only on demand. 翻译一下： 某些应用需要特定的地址空间用于捕获内存捕获监测，一但某些代码开辟了这块空间，就捕获这个事件 预留连续的空间，后续再使用，比如开辟一条线程时，会先预留 1MB 的空间，而不会直接提交到物理内存 关于「32位程序」和「32位CPU」的 Q&amp;AQ1. 为什么 8G 甚至 16G 物理内存的笔记本电脑跑 winp32 程序还是会 OOM？ A：win32程序的内存瓶颈在于虚拟内存不足，而不是物理内存 下面做个比喻，解释 32位程序虚拟内存和物理内存的关系是什么。 比如虚拟内存是学校，物理内存是宿舍。 学校盖的大，能招的学生就多，程序能分配的虚拟内存空间就大。 如果学校盖的小，宿舍盖的大，那么宿舍一定会有空位，因为学校就算招满人了，宿舍也住不满（代表了单进程，虚拟内存小于物理内存的情况，不考虑使用 PAE 技术的情况） 如果学校盖的大，宿舍盖的小，宿舍就会住满。那么就需要设定策略，让更需要住宿的同学住进宿舍，不太需要住宿的同学就要搬出宿舍，给需要的同学腾出位置（代表了虚拟内存大于物理内存的情况下，物理内存打满后，需要将不需要的内存数据写入磁盘） Q2. 为什么32位程序瓶颈是在虚拟内存上？ A: 32位进程，虚拟内存空间是 4GB，Windows系统中，内核空间占用 2GB，用户空间只有 2GB 32位程序\\操作系统的指针只能表示 2^32 = 4GB 范围内的地址，所以我们开辟的虚拟内存也只能在 4GB 以内。 一个进程的内存空间布局是什么样子，为什么我们可用的空间只有 2GB 会在介绍 Windows 进程内存布局一节中回答。 Q3. 32位CPU和32位操作系统的关系是什么？ A：32位操作系统的一条指令是32位，32位CPU一个时钟周期正好处理一条32位指令 32位CPU 是不能使用 64 位操作系统的，因为 64位操作系统一条指令是 64位，32位 CPU 无法处理 反过来，64位CPU 可以运行 32位操作系统，但无法发挥出 CPU 的全部能力，有点「大马拉小车」的感觉 Q4. 32位CPU只能使用 4GB 的物理内存么？CPU的寻址能力和CPU的位宽相关么？ A：不是。不相关，CPU的寻址范围和CPU的位宽毫无关系 寻址范围和地址线宽度有关，和 CPU 位宽无关，Intel 32位CPU 早在1995年就支持36位地址线了，也就是 32位CPU 能使用 64GB 的物理内存 为什么能访问更大的内存地址？可以详细了解 PAE（Physical Address Extension） 技术 PAE 技术是为了让多个 32位进程累计使用内存的情况下，能使用更多的物理内存（超过4GB） Windows 内存布局（Windows Process Virtual Space)用户地址空间（User Address Space Layout）我们重点关注我们能用到的地址空间是什么样子的，对内核空间感兴趣的同学可以自己查阅其他资料。 下图出自《Windows Internals 6》 我们知道程序需要先被加载到内存中，才能运行 上图描述了 x86（32位）进程的内存布局： 分为了 3GB 的用户空间，和 1GB 的内核空间，但这并不是 Win32 程序的正常布局，而是开启了大地址空间模式的程序（LARGE_ADDRESS_AWARE） 正常的 Win32 程序用户空间只有 2GB，内核空间也占用 2GB 用户空间占用低地址（00000000 ~ 7FFFEFFF），内核空间占用高地址(7FFF000 ~ FFFFFFFF) 用户空间存放了「代码」「全局变量」「线程栈」「DLL」等 内核空间图中详细标明了包含什么，本文不再赘述，感兴趣的同学可以自行了解 上图详细描述了用户空间的布局： 最低地址存放了 .exe 然后是 .dll 然后是 Heap，Heap 中存放的是通过 HeapAlloc 等 API 分配的堆内存 然后是 Thread Stack，存放的是线程栈内存，每开一条新线程就会对应开辟一块栈内存 图中还提到了 ASLR，这是什么，后文会具体介绍。 下面，再来看一张图，此图出自《程序员的自我修养》 图中描述的用户空间非常「碎片化」，这可能也和 ASLR 相关。如果你要分析应用的虚拟内存布局，不要完全以图中的布局为准，要以自己程序真正运行的情况为准。 这是书中对地址空间如何计算的一些描述： 线程栈、进程堆、已装载的镜像文件（exe、dll）的地址是动态计算获得的 其中 exe dll 需要应用支持 ASLR（随机选择地址） ASLR 是什么？下面具体看看，到底什么是 ASLR ASLR 全称是 Address Space Layout Randomization，可以翻译为随机地址空间 目的是为了防御恶意软件做注入攻击，因为固定地址更容易被攻击者破译 这么做随之而来的缺点是更容易造成「内存碎片化」 如何关闭 ASLR？ 修改链接器高级配置，关闭随机基址（/DYNAMICBASE:NO) 此能力我没有亲自试验过，有需求的同学可以自己尝试 Stacks在 Windows 中，Memory Manager 会为每个线程提供两个栈，用户栈(user stack)和内核栈(kernel stack) 我们仍然只总结用户栈 线程创建时，默认预留 1MB 虚拟内存 通过编译器指定参数 /STACK:reverse 可以将预留内存大小写入 PE Header 中（修改 stack size） 尽管预留了 1 MB 虚拟内存，但只有 first page 虚拟内存会被提交（真正分配） 64 位系统跑 32 位程序，最大线程数量比 32 位机器跑 32 程序要少 原因是 64 位机器跑 32 位程序，会额外创建 64 位的栈，同样只有 2GB 虚拟内存空间，但每个线程重复消耗了两份内存 实测，64 位栈占用 256 kb 内存，每个线程栈合计占用 1.25 MB 总结，理论上在 64位系统上跑 32位程序，会有额外的开销，本来 32 位程序虚拟内存只有 2GB 可用，运行在 64 位系统上时会更快的暴露这个短板。想了解更多的同学可以去查阅一下 WoW64(windows on windows64)相关内容 分析 Windows 虚拟内存的利器，VMMap上面介绍了那么多理论，实际上我们该如何分析应用的虚拟内存呢？ 官方为我们提供了一款工具 vmmap 内存区域含义 Total:：总的分配过的虚拟内存 Free：可用的虚拟内存 Image：exe dll 占用的虚拟内存 Private data：进程私有的堆占用的内存 Stack：线程栈占用的虚拟内存 我们也可以打开 vmmap 点 help 进行查看每个区域的具体含义 CLI 除了 GUI，vmmap 也提供了 CLI 供我们在脚本中使用 如何解决 Win32 程序的虚拟内存瓶颈？介绍了理论和工具，如何解决实际问题呢？ 将 32位程序升级为 64位虚拟内存在 64位程序上将不会成为瓶颈，但将现有程序改为 64位并不是一件容易的事，具体需要做什么就不再本文赘述了。 缩小冗余的预留空间（Reserved） 减小线程栈分配空间，在上文得出结论，默认情况下，32位程序跑在64位系统上，每条线程需要开辟 1.25MB内存，那我们可以适当减小栈大小。如果是 java 程序可以通过JVM启动参数 Xss 来减少栈空间 减少大的预留的堆空间，比如 java 程序在 JVM 启动的时候就会预留分配 XmX 大小的空间，如果是 1GB，就占用了一半的空间。 扩大进程虚拟内存空间 默认情况，进程虚拟内存大小 2GB 如果 exe 做大地址空间标记且系统启动使用了特殊参数，可以将进程虚拟内存大小升至 3GB 下面讲具体该怎么做 在编译 exe 的时候需要指定 Linker 参数 LARGE_ADDRESS_AWARE 为 YES 需要用管理员模式打开 cmd，然后输入命令 bcdedit /set increaseuserva 3072，3072 表示 3GB 如何检查大地址空间模式是否生效？ 确认 windows 系统是否通过 bcdedit 设置了参数，用管理员模式打开 cmd，输入 bcdedit，看列表中是否有 increaseuserva 3072，如果有就进行下一步 使用 dumpbin /headers 查看 exe 是否开启了大地址空间模式 参考《Windows Internal 6》《Windows Internal 7》《程序员的自我修养》 https://hansimov.gitbook.io/csapp/part2/ch09-virtual-memory https://docs.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/virtual-address-spaces https://news.mydrivers.com/1/571/571392.htm https://www.zhihu.com/question/382484336 https://stackoverflow.com/questions/16264118/how-jvm-stack-heap-and-threads-are-mapped-to-physical-memory-or-operation-syste https://stackoverflow.com/questions/9560993/how-do-you-disable-aslr-address-space-layout-randomization-on-windows-7-x64 https://docs.microsoft.com/en-us/cpp/build/reference/dynamicbase-use-address-space-layout-randomization?redirectedfrom=MSDN&amp;view=msvc-170 https://stackoverflow.com/questions/2440434/whats-the-difference-between-reserved-and-committed-memory https://docs.microsoft.com/en-us/archive/blogs/markrussinovich/pushing-the-limits-of-windows-virtual-memory","categories":[{"name":"Windows","slug":"Windows","permalink":"https://zzt.github.io/categories/Windows/"}],"tags":[]},{"title":"【Kotlin Compiler】IR Transform Plugin 教程","slug":"kt-complier-plugin","date":"2022-05-29T12:37:37.000Z","updated":"2022-05-31T04:09:24.361Z","comments":true,"path":"2022/05/29/kt-complier-plugin/","link":"","permalink":"https://zzt.github.io/2022/05/29/kt-complier-plugin/","excerpt":"","text":"【Kotlin Compiler】IR Transform Plugin 教程 本文会通过一个小 demo 手把手教你学会如何利用 Kotlin Compiler Plugin 进行 IR 插桩。如果你对 IR（intermediate representation） 是什么还一知半解，不妨先参考 【Kotlin Compiler】IR 介绍 如果你想直接参考源码，可以直接看这里，如果能点个 star 就更好了 下面开始正题 我们的目标是什么？先来看两段代码12345678fun foo(param1: String? = &quot;Hello&quot;, param2: String? = &quot;World&quot;): String &#123; println(&quot;foo costs[$&#123;startTime.elapsedNow()&#125;]&quot;) val startTime = TimeSource.Monotonic.markNow() //类似 Java 中的 System.currentMills() // do something cost time val result = param1 + param2 println(&quot;foo costs[$&#123;startTime.elapsedNow()&#125;]&quot;) return result&#125; 这是我们日常通过 log 统计方法耗时的一个小例子，如果需要统计的方法数量较多，我们要手写非常多的重复代码。 在 Java 中，我们可以找到被注解标注的方法，然后通过 Transform 字节码的方式将模板代码插到指定位置。在 Kotlin 中，方案是一样的，只不过我们需要 Transform 的不是字节码了，而是 IR。做完 Transform 的工作后，只需写下面这段代码就可满足需求。 1234@Costfun foo(param1: String? = &quot;Hello&quot;, param2: String? = &quot;World&quot;): String &#123; return param1 + param2&#125; 怎样开发一个 Kotlin Compiler Plugin？了解完我们的目标后，就需要了解开发一个 Kotlin Compiler Plugin 的标准过程是什么？我们需要了解那些概念，要用哪些 API？ 下面我们先来看看如何开发 Kotlin Compiler Plugin 此图是 Kotlin Compiler Plugin 的架构图，我已经在图中标注了每个模块的职责是什么，不再赘述。 0.工程搭建环境说明： IDE-IntelliJ IDEA 2021.3.3 (Community Edition) KotlinPlugin-1.6.21 JDK-1.8 下面是工程中需要依赖的库和插件，详细可参考Sample代码依赖12345678910111213141516apply plugin: &quot;java-gradle-plugin&quot;apply plugin: &quot;org.jetbrains.kotlin.jvm&quot;apply plugin: &quot;kotlin-kapt&quot;dependencies &#123; implementation gradleApi() implementation(&quot;org.jetbrains.kotlin:kotlin-stdlib:1.6.21&quot;) // kotlin 标准库 implementation(&quot;org.jetbrains.kotlin:kotlin-gradle-plugin-api:1.6.21&quot;) // kotlin-插件 api implementation(&quot;org.jetbrains.kotlin:kotlin-compiler-embeddable:1.6.21&quot;) // kotlin-插件 api 注意：如果需要用 com.github.tschuchortdev:kotlin-compile-testing，这里必须使用 embeddable 版本 implementation &quot;com.google.auto.service:auto-service:1.0.1&quot; //auto-service，找到插件中的具体实现类 kapt &quot;com.google.auto.service:auto-service:1.0.1&quot; //kapt 生成映射代码 testImplementation &#x27;org.junit.jupiter:junit-jupiter:5.8.1&#x27; // junit engine testImplementation &#x27;org.jetbrains.kotlin:kotlin-test-junit:1.6.21&#x27; testImplementation(&quot;com.github.tschuchortdev:kotlin-compile-testing:1.4.8&quot;) //compiler plugin / ksp plugin 单测扩展库&#125; 1.KotlinCompilerPluginSupportPlugin此类是 Gradle 和 Kotlin 的桥梁，主要职责是提供插件入口，获取插件 AGV（artifact group version） 12345678910111213141516171819class MethodPerfIRPlugin: KotlinCompilerPluginSupportPlugin &#123; override fun applyToCompilation(kotlinCompilation: KotlinCompilation&lt;*&gt;): Provider&lt;List&lt;SubpluginOption&gt;&gt; &#123; val project = kotlinCompilation.target.project val extension = project.extensions.getByType(MethodPerfExtension::class.java) as MethodPerfExtension //可以获取到 build.gradle 中定义的一些配置，透传到 kotlin plugin 中 return project.provider &#123; listOf( SubpluginOption(key = &quot;string&quot;, value = extension.string), SubpluginOption(key = &quot;file&quot;, value = extension.file), ) &#125; &#125; /** * [isApplicable] is checked against compilations of the project, and if it returns true, * then [applyToCompilation] may be called later. */ override fun isApplicable(kotlinCompilation: KotlinCompilation&lt;*&gt;): Boolean = project.plugins.hasPlugin(MethodPerfIRPlugin::class.java)&#125; 重点要说的是 applyToCompilation，isApplicable 两个方法： isApplicable比较简单，只有当其返回 true 的时候，applyToCompilation才会执行 applyToCompilation 重点是返回值，在 build.gradle 的一些自定义配置可以通过这里透传到 Kotlin Compiler Plugin 中来，方便后续使用 2.CommandLineProcessor123456789101112131415161718192021222324252627282930313233343536@AutoService(CommandLineProcessor::class) // don&#x27;t forget itclass MethodPerfCommandLineProcessor : CommandLineProcessor &#123;// 指明插件 idoverride val pluginId: String = &quot;com.zzt.demo.kt-method-perf-plugin&quot;// 自定义 cli optionoverride val pluginOptions: Collection&lt;AbstractCliOption&gt; = listOf( CliOption( optionName = OPTION_STRING, valueDescription = &quot;string&quot;, description = &quot;sample string argument&quot;, required = false, ), CliOption( optionName = OPTION_FILE, valueDescription = &quot;file&quot;, description = &quot;sample file argument&quot;, required = false, ), )// 解析 cli 参数override fun processOption( option: AbstractCliOption, value: String, configuration: CompilerConfiguration ) &#123; println(&quot;processOption:: option=$option value=$value&quot;) return when (option.optionName) &#123; OPTION_STRING -&gt; configuration.put(ARG_STRING, value) OPTION_FILE -&gt; configuration.put(ARG_FILE, value) else -&gt; throw IllegalArgumentException(&quot;Unexpected config option $&#123;option.optionName&#125;&quot;) &#125; &#125;&#125; 此类和 ComponentRegistrar 是我们写插件真正的入口，CommandLineProcessor 的作用是解析 cli 中的参数并保存下来，本次目标不涉及，大家有兴趣或有需求可以自己研究。 需要注意的是，此类一定要用 @AutoService 标记，否则无法调用到我们的实现 3.ComponentRegistrar1234567891011@AutoService(ComponentRegistrar::class) // don&#x27;t forget itclass MethodPerfComponentRegistrar: ComponentRegistrar &#123; override fun registerProjectComponents(project: MockProject, configuration: CompilerConfiguration) &#123; println(&quot;registerProjectComponents:: $&#123;project.name&#125;&quot;) val string = configuration.get(MethodPerfCommandLineProcessor.ARG_STRING, &quot;String&quot;) val file = configuration.get(MethodPerfCommandLineProcessor.ARG_FILE, &quot;File&quot;) IrGenerationExtension.registerExtension(project, MethodPerfExtension(string, file)) &#125;&#125; 此类的作用有两个： 使用 CommanLineProcessor 中保存好的 option，本次逻辑不涉及，参考代码写法即可 注册 Extension，下面具体看 Extension 是什么 同样注意，不要忘记加 @AutoService 4.Extension重点来了，我们 80% 的逻辑可能都写在 Extension 中，通过此类我们可以对 IR 进行增删改，具体如下 12345class MethodPerfExtension(): IrGenerationExtension &#123; override fun generate(moduleFragment: IrModuleFragment, pluginContext: IrPluginContext) &#123; // transform IR &#125;&#125; 此类中只有 generate 方法，其中包含两个参数： IrModuleFragment 代表 IR 树的根节点，描述的是 module 相关的信息，比如里面是一组 irFile，自顶向下遍历可以得到整个 module 的 ir 信息 IrPluginContext 包含了大多数我们在 transform IR 时用到的 api 和信息 Dump IR 树 在 Kotlin IR 中，IrElement 是一切 IR 结构的父类，我们可以通过其扩展方法 IrElement.dump 查看 IR 树是怎样的结构。 比如，我们在 generate 中调用 moduleFragment.dump()，来查看下面代码的 IR 123fun main() &#123; println(&quot;Hello, World!&quot;)&#125; 会得到 12345678MODULE_FRAGMENT name:&lt;main&gt; FILE fqName:&lt;root&gt; fileName:/var/folders/lt/k622ndqs14l7_tcxst93z3cm0000gp/T/Kotlin-Compilation7335327567848552666/sources/main.kt FUN name:main visibility:public modality:FINAL &lt;&gt; () returnType:kotlin.Unit BLOCK_BODY CALL &#x27;public final fun println (message: kotlin.Any?): kotlin.Unit [inline] declared in kotlin.io.ConsoleKt&#x27; type=kotlin.Unit origin=null message: CONST String type=kotlin.String value=&quot;Hello, World!&quot; 实现目标了解 Kotlin Complier Plugin 的基本情况后，你应该大致清楚了开发插件的过程。下面我们通过完成目标，加深对这个过程的理解。 0.技术方案 Transform 流程并不复杂，主要包含了： 找到加注解的方法 重写方法体 IRa. 增加时间戳b. 原始方法体c. 统计耗时 如果方法包含返回值，需要先保存返回值，再进行统计耗时 1.开发 IrElementTransformerIrElementTransformer 继承自 IrElementVisitor，功能类似，不再赘述。 直接看一下代码，我们在 IrElementTransformer 中做了什么1234567891011121314class MethodCostTimeTransformer( private val pluginContext: IrPluginContext): IrElementTransformerVoidWithContext() &#123; override fun visitFunctionNew(declaration: IrFunction): IrStatement &#123; println(&quot;visitFunctionNew:: $&#123;declaration.render()&#125;&quot;) val body = declaration.body val annotationClass = pluginContext.referenceClass(FqName(&quot;com.zzt.demo.annotation.Cost&quot;))!! if (body != null &amp;&amp; declaration.hasAnnotation(annotationClass)) &#123; //有方法体&amp;被注解标注的方法 declaration.body = irCost(declaration, body) //transform 方法体 &#125; return super.visitFunctionNew(declaration) &#125;&#125;逻辑比较清晰，找到我们定义的注解，看被 visit 的方法是否加了注解，如果加了，就调用 irCost() Transform 方法体 IR 下面看看 irCost() 做了什么123456789101112131415161718private fun irCost( irFunction: IrFunction, irBody: IrBody): IrBlockBody &#123; println(&quot;irCost:: &quot;) return DeclarationIrBuilder(pluginContext, irFunction.symbol).irBlockBody &#123; +costEnter(pluginContext, irFunction) //打印目标函数信息 val startTime = irTemporary(irCall(pluginContext.markNowFunc()).also &#123; it.dispatchReceiver = irGetObject(pluginContext.monotonicClass()) &#125;) // 相当于调用 TimeSource.Monotonic.markNow() +irBlock(resultType = irFunction.returnType) &#123; for(statement in irBody.statements) &#123; //原有方法体中的表达式 +statement &#125; &#125;.transform(CostTimeReturnTransformer(pluginContext, irFunction, startTime), null) &#125;&#125; 在方法耗时统计之前，通过 costEnter() 插桩打印目标函数的信息，比如方法名，参数是什么 调用 TimeSource.Monotonic.markNow() 记录开始时间 startTime 追加原有方法体内容，并开始进行返回体的 Transform 2. CostTimeReturnTransformer1234567891011121314151617181920212223242526class CostTimeReturnTransformer( private val pluginContext: IrPluginContext, private val irFunction: IrFunction, private val startTime: IrValueDeclaration): IrElementTransformerVoidWithContext() &#123; override fun visitReturn(expression: IrReturn): IrExpression &#123; println(&quot;visitReturn:: $&#123;expression.render()&#125;&quot;) if (expression.returnTargetSymbol != irFunction.symbol) //只 transform 目标函数 return super.visitReturn(expression) println(&quot;transform return:: &quot;) return DeclarationIrBuilder(pluginContext, irFunction.symbol).irBlock &#123; if (irFunction.returnType == pluginContext.irBuiltIns.unitType) &#123; +costExit(pluginContext, irFunction, startTime) return@irBlock &#125; val result = irTemporary(expression.value) //保存返回表达式 +costExit(pluginContext, irFunction, startTime, irGet(result)) // 将统计时间逻辑插到 return 之前 +expression.apply &#123; value = irGet(result) // 将原有的返回表达式补回 &#125; &#125; &#125;&#125; 上述代码逻辑也比较清晰 如果不是目标函数，直接 return 如果目标函数无返回值，直接插桩 costExit() 如果有返回值，则需要先保存返回值到临时变量，然后再插桩 costExit()，并且要补上原有的返回值，否则会造成方法一直返回 null 的情况 3. 测试https://github.com/tschuchortdev/kotlin-compile-testing 此库专用于 Kotlin Compiler Plugin 或者 KSP Plugin 的单测，让我们不需要将插件集成到目标工程就能进行测试，且容易上手，推荐大家使用。 但目前有个库兼容问题需要注意，我们在开发插件时必须依赖 implementation(&quot;org.jetbrains.kotlin:kotlin-compiler-embeddable:1.6.21&quot;)，不能使用 implementation(&quot;org.jetbrains.kotlin:kotlin-compiler:1.6.21&quot;) 下面就看看如何进行测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class MethodPerfTest &#123; @Test fun `IR plugin`() &#123; // val result = compile(// sourceFile = SourceFile.fromPath(File(&quot;&#123;path&#125;/main.kt&quot;))// ) val result = compile( sourceFile = SourceFile.kotlin(&quot;main.kt&quot;, &quot;&quot;&quot; import com.zzt.demo.annotation.Cost fun main() &#123; println(foo()) println(foo(&quot;Transform&quot;, &quot;Kotlin IR&quot;)) &#125; @Cost fun foo(param1: String? = &quot;Hello&quot;, param2: String? = &quot;World&quot;): String &#123; println(&quot;foo called param1=[$&#123;&#x27;$&#x27;&#125;param1], param2=[$&#123;&#x27;$&#x27;&#125;param2]&quot;) //注意 $ 需要转义 return param1 + param2 &#125; &quot;&quot;&quot;.trimIndent()) ) assertEquals(KotlinCompilation.ExitCode.OK, result.exitCode) //类加载目标产物，看最终运行结果是否符合预期 val ktClazz = result.classLoader.loadClass(&quot;MainKt&quot;) val main = ktClazz.declaredMethods.single &#123; it.name == &quot;main&quot; &amp;&amp; it.parameterCount == 0 &#125; main.invoke(null) &#125; fun compile( sourceFiles: List&lt;SourceFile&gt;, plugin: ComponentRegistrar = MethodPerfComponentRegistrar(), ): KotlinCompilation.Result &#123; return KotlinCompilation().apply &#123; sources = sourceFiles useIR = true compilerPlugins = listOf(plugin) inheritClassPath = true &#125;.compile() &#125; fun compile( sourceFile: SourceFile, plugin: ComponentRegistrar = MethodPerfComponentRegistrar(), ): KotlinCompilation.Result &#123; return compile(listOf(sourceFile), plugin) &#125;&#125; 通过 SourceFile.kotlin 或 SourceFile.fromPath() 可以传入需要测试的代码 测试代码会通过集成了 MethodPerfComponentRegistrar 的 kt 编译器进行编译 通过类加载目标代码，反射调用 main 函数，看执行结果是否正确 下面看看 Transform IR 的结果 1234567891011121314⇢ foo(param1=Hello, param2=World) start function body ...foo called param1=[Hello], param2=[World]Hello, Worldend function body ⇠ foo costs [1.02ms] returnValue=HelloWorld⇢ foo(param1=Transform, param2=Kotlin IR) start function body ...foo called param1=[Transform], param2=[Kotlin IR]Hello, Worldend function body ⇠ foo costs [41.0us] returnValue=TransformKotlin IR 参考 Writing Your First Kotlin Complier Plugin Writing Your Second Kotlin Compiler Plugin, Part 5 — Transforming Kotlin IR","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://zzt.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin Compiler","slug":"Kotlin-Compiler","permalink":"https://zzt.github.io/tags/Kotlin-Compiler/"}]},{"title":"【Kotlin Compiler】IR 介绍","slug":"kt-ir","date":"2022-05-29T12:37:24.000Z","updated":"2022-05-31T04:09:32.608Z","comments":true,"path":"2022/05/29/kt-ir/","link":"","permalink":"https://zzt.github.io/2022/05/29/kt-ir/","excerpt":"","text":"【Kotlin Compiler】IR 介绍 本文会介绍 Kotlin Compiler 中 IR 是什么，以及操作 IR 的 api 是什么在了解 IR 相关 api 后，可以继续学习 IR Transform Plugin 教程，自己动手制作一个 Transform IR 的插件 Kotlin IR 是什么 IR 全称是 intermediate representation，表示编译过程中的中间信息，由编译器前端对源码分析后得到，随后会输入到后端进一步编译为机器码 IR 可以有一系列的表现方式，由高层表示逐渐下降(lowering)到低层 我们所讨论的 Kotlin IR 是抽象语法树结构（AST），是比较高层的 IR 表示类型。 有了完备的 IR，就可以利用不同的 后端，编出不同的目标代码，比如 JVM 的字节码，或者运行在 iOS 的机器码，这样就达到了跨端的目的，想了解更多 kotlin 跨端技术可以参考 https://kotlinlang.org/docs/multiplatform-mobile-getting-started.html 如何查看 Kotlin IR 结构IR 树示例我们先看一个例子，直观感受一下 IR 树是什么样子的 123fun main() &#123; println(&quot;Hello, World!&quot;)&#125; 上述代码在转成 IR 信息后，是这样的 1234567MODULE_FRAGMENT name:&lt;main&gt; FILE fqName:&lt;root&gt; fileName:/var/folders/lt/k622ndqs14l7_tcxst93z3cm0000gp/T/Kotlin-Compilation7335327567848552666/sources/main.kt FUN name:main visibility:public modality:FINAL &lt;&gt; () returnType:kotlin.Unit BLOCK_BODY CALL &#x27;public final fun println (message: kotlin.Any?): kotlin.Unit [inline] declared in kotlin.io.ConsoleKt&#x27; type=kotlin.Unit origin=null message: CONST String type=kotlin.String value=&quot;Hello, World!&quot; IrElement 和 IrElementVisitor 查看 IR 的 Api 中，最重要的是 IrElement 和 IrElementVisitor IrElement 是所有 IR 元素的父类，包含两个抽象方法12fun &lt;R, D&gt; accept(visitor: IrElementVisitor&lt;R, D&gt;, data: D): Rfun &lt;D&gt; acceptChildren(visitor: IrElementVisitor&lt;Unit, D&gt;, data: D): Unitaccept 一般会调用 visitor 对应的 visitXXX 方法acceptChildren 会依次调用 IR 子元素的 accept 方法 下面看看 IrClass 的具体实现，便于我们理解12345678override fun &lt;R, D&gt; accept(visitor: IrElementVisitor&lt;R, D&gt;, data: D): R = visitor.visitClass(this, data) // 调用 visitor 对应的 visitClassoverride fun &lt;D&gt; acceptChildren(visitor: IrElementVisitor&lt;Unit, D&gt;, data: D) &#123; // 遍历 IrClass 子元素，并调用对应的 accept 方法 thisReceiver?.accept(visitor, data) typeParameters.forEach &#123; it.accept(visitor, data) &#125; declarations.forEach &#123; it.accept(visitor, data) &#125;&#125; 输入和输出我们注意到 Visitor 中还包含了 &lt;R, D&gt; 两个泛型参数，D 作为参数传入，R 作为返回值，这分别代表什么意思呢？ D data 表示在 visit ir 时的输入数据，我们可以把想要传递的上下文信息通过这个参数传入，在具体 visit 的过程中使用。 比如，我们可以修改打印 IR 元素前的缩进，或是随便插入什么其他信息都可以1234567class StringIndentVisitor : IrElementVisitor&lt;Unit, String&gt; &#123; override fun visitElement(element: IrElement, data: String) &#123; println(&quot;$data$&#123;render(element)&#125; &#123;&quot;) element.acceptChildren(this, &quot; $data&quot;) println(&quot;$data&#125;&quot;) &#125;&#125; R 表示在 accept visitor 时拿到的返回结果，在较少的 Transform ir 场景我们会用到这个能力，其他情况使用 Unit 即可。下面有个真实场景不会用到的例子，但能说明返回值的用法。 123456789// Not as efficient as a while loop, but exemplifies how the output type could be usedclass RootParentVisitor : IrElementVisitor&lt;IrDeclarationParent?, Nothing?&gt; &#123; override fun visitElement(element: IrElement, data: Nothing?): IrDeclarationParent? = null override fun visitDeclaration(declaration: IrDeclarationBase, data: Nothing?): IrDeclarationParent &#123; val parent = declaration.parent return parent.accept(this, null) ?: parent &#125;&#125; 另外。我们可以注意到 acceptChildren 接收的 visitor 泛型是 ，也就是说我们不能在通过 acceptChildren 遍历 IR 树的过程中获取返回值，如果你需要在过程中保存一些信息，可以从外部传入一个变量保存。比如 123456789101112class CollectingVisitor( private val elements: MutableList&lt;IrElement&gt;) : IrElementVisitor&lt;Unit, Nothing?&gt; &#123; override fun visitElement(element: IrElement, data: Nothing?) &#123; elements.add(element) element.acceptChildren(this, data) &#125;&#125;fun collect(element: IrElement) = buildList&lt;IrElement&gt; &#123; element.accept(CollectingVisitor(this), null)&#125; 自顶向下遍历 IR 树 了解了 IrElement 和 IrElementVisitor 后，我们可以自己实现一个类似 IrElement.dump() 的功能。通过重写 visitElement，在其中进行 acceptChildren，就能自顶向下递归遍历 IR 树，通过 element.render() 打印每个 IR 元素，代码如下 123456class RecursiveVisitor: IrElementVisitor&lt;Unit, Nothing?&gt; &#123; override fun visitElement(element: IrElement, data: Nothing?) &#123; println(&quot;visitElement:: $&#123;element.render()&#125;&quot;) element.acceptChildren(this, data) &#125;&#125; 其他 IR 操作 API创建方法调用 IR12345678910// 通过传入方法全限定名找到具体方法 ir，除了方法还有找 class 等 apival printlnFunc = irPluginContext.referenceFunctions(FqName(&quot;kotlin.io.println&quot;)).single &#123; val parameters = it.owner.valueParameters parameters.size == 1 &amp;&amp; parameters[0].type == irPluginContext.irBuiltIns.anyNType&#125;//通过传入 IrFunction 到 irCall 完成方法的调用，其中 putValueArgument 可以向目标函数传入参数irCall(printlnFunc).also &#123; it.putValueArgument(0, irString(&quot;Hello, World&quot;))&#125; 拼接字符串123val concat = irConcat() concat.addArgument(irString(&quot;a&quot;)) concat.addArgument(irString(&quot;b&quot;)) 创建局部变量 IR，获取变量值12345val i = irTemporary(irConcat().also &#123; // i = &quot;Hello, World&quot; it.addArgument(irString(&quot;Hello, World&quot;)) &#125;)irGet(i) // 得到 i 的值 &quot;Hello, World&quot; 修改方法体123456DeclarationIrBuilder(irPluginContext, irFunction.symbol).irBlockBody &#123; +irCall(...) // 可通过加号 插入自己的方法调用 for(statement in irBody.statements) &#123; //原有方法体中的表达式 +statement &#125;&#125; 持续补充…参考Writing Your Second Kotlin Compiler Plugin, Part 2 — Inspecting Kotlin IR Writing Your Second Kotlin Compiler Plugin, Part 3 — Navigating Kotlin IR","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://zzt.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin Compiler","slug":"Kotlin-Compiler","permalink":"https://zzt.github.io/tags/Kotlin-Compiler/"}]},{"title":"不定积分基本公式与推导","slug":"basic-integral","date":"2022-05-03T07:28:33.000Z","updated":"2022-05-04T02:41:03.222Z","comments":true,"path":"2022/05/03/basic-integral/","link":"","permalink":"https://zzt.github.io/2022/05/03/basic-integral/","excerpt":"","text":"不定积分基本公式与推导1∫ ax dx=axlna+C,(ax)′=axlna\\int\\ a^x\\,dx=\\dfrac{a^x}{lna} + C,\\quad ({a^x})&#x27; = a^x lna∫ axdx=lnaax​+C,(ax)′=axlna 2∫tan⁡x dx=∫sinxcosx dx=−∫1cosx d(cosx)=−ln⁡∣cos⁡x∣+C\\int\\tan x\\,dx=\\int\\dfrac{sinx}{cosx}\\,dx=-\\int\\dfrac{1}{cosx}\\,d(cosx)=-\\ln{|\\cos{x}|} + C∫tanxdx=∫cosxsinx​dx=−∫cosx1​d(cosx)=−ln∣cosx∣+C ∫cot⁡x dx=∫cosxsinx dx=−∫1sinx d(sinx)=ln⁡∣sin⁡x∣+C\\int\\cot x\\,dx=\\int\\dfrac{cosx}{sinx}\\,dx=-\\int\\dfrac{1}{sinx}\\,d(sinx)=\\ln{|\\sin{x}|} + C∫cotxdx=∫sinxcosx​dx=−∫sinx1​d(sinx)=ln∣sinx∣+C 3∫1cosx dx=∫sec⁡x dx=∫cosx(cosx)2 dx=∫cosx1−(sinx)2 dx=∫11−(sinx)2 d(sinx)=∫1(1+sinx)(1−sinx) d(sinx)=12[∫11+sinx d(sinx)−∫11−sinx d(sinx)]=12ln∣1+sinx1−sinx∣+C=12ln∣(1+sinx)2(cosx)2∣=ln∣1+sinxcosx∣=ln∣secx+tanx∣+C\\int\\dfrac{1}{cosx}\\,dx =\\int\\sec{x}\\,dx\\\\ =\\int\\dfrac{cosx}{(cosx)^2}\\,dx =\\int\\dfrac{cosx}{1-(sinx)^2}\\,dx \\\\ =\\int\\dfrac{1}{1-(sinx)^2}\\,d(sinx)=\\int\\dfrac{1}{(1+sinx)(1-sinx)}\\,d(sinx) \\\\ =\\dfrac{1}{2}[\\int\\dfrac{1}{1+sinx}\\,d(sinx) - \\int\\dfrac{1}{1-sinx}\\,d(sinx)] \\\\ =\\dfrac{1}{2}ln|\\dfrac{1+sinx}{1-sinx}| + C \\\\ =\\dfrac{1}{2}ln|\\dfrac{(1+sinx)^2}{(cosx)^2}|=ln|\\dfrac{1+sinx}{cosx}| \\\\ =ln|secx + tanx| + C∫cosx1​dx=∫secxdx=∫(cosx)2cosx​dx=∫1−(sinx)2cosx​dx=∫1−(sinx)21​d(sinx)=∫(1+sinx)(1−sinx)1​d(sinx)=21​[∫1+sinx1​d(sinx)−∫1−sinx1​d(sinx)]=21​ln∣1−sinx1+sinx​∣+C=21​ln∣(cosx)2(1+sinx)2​∣=ln∣cosx1+sinx​∣=ln∣secx+tanx∣+C ∫1sinx dx=∫csc⁡x dx=∫sinx(sinx)2 dx=∫sinx1−(cosx)2 dx=−∫11−(cosx)2 d(cosx)=−∫1(1+cosx)(1−cosx) d(cosx)=−12[∫11+cosx d(cosx+1)−∫11−cosx d(1−cosx)]=−12ln∣1+cosx1−cosx∣=−12ln(sinx)2(1−cosx)2=ln∣1−cosxsinx∣=ln∣cscx+cotx∣+C\\int\\dfrac{1}{sinx}\\,dx =\\int\\csc{x}\\,dx \\\\ =\\int\\dfrac{sinx}{(sinx)^2}\\,dx =\\int\\dfrac{sinx}{1-(cosx)^2}\\,dx \\\\ =-\\int\\dfrac{1}{1-(cosx)^2}\\,d(cosx)=-\\int\\dfrac{1}{(1+cosx)(1-cosx)}\\,d(cosx) \\\\ =-\\dfrac{1}{2}[\\int\\dfrac{1}{1+cosx}\\,d(cosx+1) - \\int\\dfrac{1}{1-cosx}\\,d(1-cosx)] \\\\ =-\\dfrac{1}{2}ln|\\dfrac{1+cosx}{1-cosx}| \\\\ =-\\dfrac{1}{2}ln\\dfrac{(sinx)^2}{(1-cosx)^2} \\\\ =ln|\\dfrac{1-cosx}{sinx}| \\\\ =ln|cscx + cotx| + C∫sinx1​dx=∫cscxdx=∫(sinx)2sinx​dx=∫1−(cosx)2sinx​dx=−∫1−(cosx)21​d(cosx)=−∫(1+cosx)(1−cosx)1​d(cosx)=−21​[∫1+cosx1​d(cosx+1)−∫1−cosx1​d(1−cosx)]=−21​ln∣1−cosx1+cosx​∣=−21​ln(1−cosx)2(sinx)2​=ln∣sinx1−cosx​∣=ln∣cscx+cotx∣+C 4∫(secx)2 dx=tanx+C,tanx′=(secx)2\\int (secx)^2\\,dx=tanx + C,\\quad tanx&#x27;=(secx)^2∫(secx)2dx=tanx+C,tanx′=(secx)2 ∫(cscx)2 dx=−cotx+C,cotx′=−(cscx)2\\int (cscx)^2\\,dx=-cotx +C,\\quad cotx&#x27;=-(cscx)^2∫(cscx)2dx=−cotx+C,cotx′=−(cscx)2 5∫secx tanx dx=∫sinx(cosx)2 dx=∫−1(cosx)2 d(cosx)=secx+C,(secx)′=secx tanx\\int secx \\; tanx\\, dx= \\int \\dfrac{sinx}{(cosx)^2}\\,dx=\\int-\\dfrac{1}{(cosx)^2}\\,d(cosx)=secx+C, \\quad (secx)&#x27;=secx\\;tanx∫secxtanxdx=∫(cosx)2sinx​dx=∫−(cosx)21​d(cosx)=secx+C,(secx)′=secxtanx ∫cscx cotx dx=∫cosx(sinx)2 dx=∫1(sinx)2 d(sinx)=−cscx+C,(cscx)′=cscx−cotx\\int cscx \\; cotx \\,dx = \\int\\dfrac{cosx}{(sinx)^2}\\,dx=\\int\\dfrac{1}{(sinx)^2}\\,d(sinx)=-cscx + C, \\quad (cscx)&#x27; = cscx - cotx∫cscxcotxdx=∫(sinx)2cosx​dx=∫(sinx)21​d(sinx)=−cscx+C,(cscx)′=cscx−cotx 6∫1a2+x2 dx=1aarctanxa+C\\int\\dfrac{1}{a^2 + x^2}\\,dx=\\dfrac{1}{a}arctan\\dfrac{x}{a} + C∫a2+x21​dx=a1​arctanax​+C ∫1a2−x2 dx=arcsinxa+C\\int\\dfrac{1}{\\sqrt{a^2 - x^2}}\\,dx=arcsin\\dfrac{x}{a} + C∫a2−x2​1​dx=arcsinax​+C 7三角函数换元∫1x2−a2 dx令 x=asect,dx=a sect tant dt=∫1atant asect tant dt=∫sect dt=ln∣sect+tant∣+C回代 xsect=xa,tant=x2−a2a=ln∣x+x2−a2∣−lna+C1=ln∣x+x2−a2∣+C\\int\\dfrac{1}{\\sqrt{x^2 - a^2}}\\,dx \\\\ 令\\; x=asect, \\quad dx=a\\;sect \\; tant \\; dt \\\\ =\\int \\dfrac{1}{atant} \\; asect \\; tant\\, dt \\\\ =\\int sect\\, dt \\\\ =ln|sect + tant| + C \\\\ 回代 \\; x sect=\\dfrac{x}{a} ,\\quad tant=\\dfrac{\\sqrt{x^2 - a^2}}{a} \\\\ =ln | x + \\sqrt{x^2 - a^2}| - lna + C_1 \\\\ =ln | x + \\sqrt{x^2 - a^2}| + C ∫x2−a2​1​dx令x=asect,dx=asecttantdt=∫atant1​asecttantdt=∫sectdt=ln∣sect+tant∣+C回代xsect=ax​,tant=ax2−a2​​=ln∣x+x2−a2​∣−lna+C1​=ln∣x+x2−a2​∣+C ∫1x2+a2 dx令 x=atant,dx=a (sect)2 dt=∫1asect a(sect)2,dt=∫sect dt=ln∣sect+tant∣+C回代 sect=x2+a2a tant=xa=ln∣x+x2+a2∣+C\\int\\dfrac{1}{\\sqrt{x^2 + a^2}}\\,dx \\\\ 令\\; x=atant, \\quad dx=a\\;(sect)^2 \\; dt \\\\ =\\int \\dfrac{1}{asect} \\; a(sect)^2, dt \\\\ =\\int sect\\, dt \\\\ =ln|sect + tant| + C \\\\ 回代 \\; sect = \\dfrac{\\sqrt{x^2 + a^2}}{a} \\; tant=\\dfrac{x}{a} \\\\ =ln|x + \\sqrt{x^2 + a^2}| + C ∫x2+a2​1​dx令x=atant,dx=a(sect)2dt=∫asect1​a(sect)2,dt=∫sectdt=ln∣sect+tant∣+C回代sect=ax2+a2​​tant=ax​=ln∣x+x2+a2​∣+C ∫a2−x2 dx令 x=asintdx=acostdt=∫a2(cost)2 dt=a2∫cos2t+12 dt=a2(sin2t4+t2)+C回代 sin2t=2sintcost=2xa2−x2a2t=arcsinxa=a22arcsinxa+x2a2−x2+C\\int\\sqrt{a^2 - x^2}\\, dx \\\\ 令\\; x=asint \\quad dx=acostdt \\\\ =\\int a^2 (cost)^2\\, dt \\\\ =a^2 \\int \\dfrac{cos2t+1}{2}\\, dt \\\\ =a^2(\\dfrac{sin2t}{4}+\\dfrac{t}{2})+ C \\\\ 回代 \\; sin2t=2sintcost=\\dfrac{2x\\sqrt{a^2-x^2}}{a^2} \\quad t=arcsin\\dfrac{x}{a} \\\\ =\\dfrac{a^2}{2}arcsin\\dfrac{x}{a} + \\dfrac{x}{2}\\sqrt{a^2 - x^2} + C∫a2−x2​dx令x=asintdx=acostdt=∫a2(cost)2dt=a2∫2cos2t+1​dt=a2(4sin2t​+2t​)+C回代sin2t=2sintcost=a22xa2−x2​​t=arcsinax​=2a2​arcsinax​+2x​a2−x2​+C 8平方差∫1x2−a2 dx=∫1(x+a)(x−a) dx=12a[∫1x+a dx−∫1x−a dx]=12alnx+ax−a+C\\int \\dfrac{1}{x^2-a^2}\\, dx \\\\ =\\int \\dfrac{1}{(x+a)(x-a)}\\, dx \\\\ =\\dfrac{1}{2a}[\\int \\dfrac{1}{x+a}\\,dx - \\int \\dfrac{1}{x-a}\\, dx]\\\\ =\\dfrac{1}{2a}ln\\dfrac{x+a}{x-a} + C∫x2−a21​dx=∫(x+a)(x−a)1​dx=2a1​[∫x+a1​dx−∫x−a1​dx]=2a1​lnx−ax+a​+C 9三角函数变换∫(cosx)2 dx=∫cos2x+12 dx=sin2x4+x2+C\\int (cosx)^2\\, dx=\\int \\dfrac{cos2x+1}{2}\\,dx=\\dfrac{sin2x}{4}+\\dfrac{x}{2}+ C∫(cosx)2dx=∫2cos2x+1​dx=4sin2x​+2x​+C∫(sinx)2 dx=∫1−cos2x2 dx=x2−sin2x4+C\\int (sinx)^2\\, dx=\\int \\dfrac{1-cos2x}{2}\\, dx=\\dfrac{x}{2} - \\dfrac{sin2x}{4} + C∫(sinx)2dx=∫21−cos2x​dx=2x​−4sin2x​+C∫(tanx)2 dx=∫(secx)2−1 dx=tanx−x+C\\int (tanx)^2\\, dx=\\int (secx)^2 - 1\\, dx=tanx - x + C∫(tanx)2dx=∫(secx)2−1dx=tanx−x+C∫(cotx)2 dx=∫(cscx)2−1 dx=−cotx−x+C\\int (cotx)^2\\, dx=\\int (cscx)^2 - 1\\, dx=-cotx - x + C∫(cotx)2dx=∫(cscx)2−1dx=−cotx−x+C","categories":[{"name":"考研","slug":"考研","permalink":"https://zzt.github.io/categories/%E8%80%83%E7%A0%94/"}],"tags":[{"name":"高数","slug":"高数","permalink":"https://zzt.github.io/tags/%E9%AB%98%E6%95%B0/"}]},{"title":"线性表","slug":"linear-list","date":"2022-01-26T14:35:02.000Z","updated":"2022-05-04T02:31:07.162Z","comments":true,"path":"2022/01/26/linear-list/","link":"","permalink":"https://zzt.github.io/2022/01/26/linear-list/","excerpt":"","text":"线性表的定义线性表是具有相同数据类型的 n (n&gt;=0) 个数据元素的有限序列。若用 L 命名线性表，则其一般表示为 $L=(a_1, a_2, … ,a_i ,a_{i+1}, …, a_n)$ 线性表的基本操作 InitList(&amp;n); 初始化表，构造一个空的线性表 Length(L); 获得线性表 L 的长度 LocateElem(L, e); 按值查找，在表 L 中找到数据元素 e GetElem(L, i); 按位查找，获取表 L 的第 i 个数据元素 ListInsert(&amp;L, i, e); 插入，向表 L 的 i 位置插入数据元素 e ListDelete(&amp;L, i, &amp;e); 删除，删除表 L 中 i 位置的元素，并将删除的值保存在 e 中 PrintList(L); 输出，按前后顺序输出表 L 中的数据元素 DestroyList(&amp;L); 销毁，销毁线性表 L，并释放 L 所占用的内存空间 顺序表的定义线性表的顺序存储称为顺序表。 重点 线性表中元素的序位是从 1 开始的，数组元素的下标是从 0 开始的 顺序表需要分配连续的内存空间，动态分配时，一旦空间沾满，就另外开辟一块更大的连续空间，用来替换原来的存储空间。比如，原表长 n，现已经存满，需要再扩充 m 个单位，则需要开辟连续的 m + n 空间，然后将原来的 n 个元素复制到新申请的空间中 综合题 从顺序表中删除具有最小值的元素（假设唯一）并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空则显示出错信息并退出运行。 12345678910111213141516bool Del_Min(sqList &amp;L, ElementType &amp;e) &#123; if (L.length == 0) &#123; return false; &#125; int index = 0; int min = L.data[0]; for(int i = 1; i &lt; L.length; i++) &#123; if (L.data[i] &lt; min) &#123; index = i; e = min; &#125; &#125; L.data[index] = L.data[L.length - 1]; L.length --;&#125; 设计一个高效算法，将顺序表 L 的所有元素逆置，要求空间复杂度为 O(1) 1234567891011void Reverse(sqList &amp;L) &#123; int head = 0; int tail = L.length - 1; while (head &lt; tail) &#123; int temp = L.data[head]; L.data[head] = L.data[tail]; L.data[tail] = temp; head ++; tail --; &#125;&#125;","categories":[{"name":"考研","slug":"考研","permalink":"https://zzt.github.io/categories/%E8%80%83%E7%A0%94/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://zzt.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"音频开发基础","slug":"audio-basic","date":"2022-01-22T17:53:41.000Z","updated":"2022-05-04T02:31:07.130Z","comments":true,"path":"2022/01/23/audio-basic/","link":"","permalink":"https://zzt.github.io/2022/01/23/audio-basic/","excerpt":"","text":"本人目前音视频技术基本零基础（在公司里耳濡目染，听过一些概念，有着肤浅的理解，实际是一头雾水），鉴于本人在短视频公司工作过（不好意思不懂这些），本身其实对这块也比较感兴趣，加上之前一直没下决心系统学习这块知识，现在想开始从零开始系统学习音视频技术，并记录学习笔记「音视频从零开始」系列，希望能帮到更多零基础想学习音视频技术的同学 注：系列文章都是通过查找各个资料加上我个人理解总结出来的学习笔记，文章最后会附上参考文章或书籍的连接，如果有理解不对或有涉及知识侵权的地方，请及时评论联系我 这是音视频技术从零开始学习笔记的第一篇，从音频技术相关的概念开始，本篇不涉及任何编程相关内容。个人认为，概念理解清楚对以后编程模块的边界、职责划分以及该使用哪些工具有很大的帮助。 图1-音频技术核心概念 采样模拟信号（连续信号）是连续的，意味着不会失真（音质好），比如磁带、唱片中就通过物理介质（通过唱片表面的起伏跌宕，或者是磁带上的磁粉引起的磁场强度来表示音箱上振膜的即时位置）保存着音频的模拟信号。 我们都知道唱片和磁带已经逐渐离开人们的视野，就是因为通过物理手段无法长久的保存音频信号，唱片会磨损，磁带会老化，那用什么方法能够长久的保存音频信息呢？ 目前，使用最多的方法就是通过数字来保存音频，那么又如何将音频转为数字呢？首先先通过图中「采样」手段，将模拟信号转为离散信号，离散信号可以理解为不连续信号，把一段连续函数按照一定规则断开。 图2-采样信号 原图链接 此图为CD标准的采样信号图，图中的「采样率44.1Khz」就是断开函数的规则，每 1s 将一段波分为 44100 个矩形，经过采样，得到了一个有一堆柱形图组成的图形（离散信号） 为什么音频的采样率是 44.1Khz 呢？对于高质量的音频（人耳能够听到的频率范围是 20hz-20Khz），根据采样定理，按比人能听到的最大频率的2倍进行采样可以保证声音在被数字化处理后，还能有质量保障 量化图3-量化（信号处理） 经过采样后，我们发现图中的纵坐标是没有值的，无法表示每段样本的数字大小，这时候就需要引入量化的概念。通俗易懂地讲「量化」就是在沿垂直方向再将信号图按照一定数字范围切断，保证每段样本能用数字描述。这个数字的最终物理意义是反应在音响振膜位置，比如用[0-10万]进行量化，最终反应在振膜的位置就是 0-10万。 那么CD的量化标准是什么呢？采用16bit(short)，也就是2的16次方，总共65536，然后为了由于振膜是可以发生正向和负向位移，所以用[-32767,32768]进行量化。 所以图中虚线范围就代表了量化的数字范围，最终的红色曲线就是量化的结果，数字信号 编码经过量化后，每一个采样都是一个数字，那这么多的数字该如何存储呢？这就需要第三个概念：「编码」，所谓编码，就是按照一定的格式记录采样和量化后的数据，比如顺序存储或压缩存储等。 这里涉及很多种格式，通常所说的音频的裸数据格式就是脉冲编码调制数据，简称 PCM （Pulse Code Modulation)。描述一段 PCM 通常需要以下三个概念 量化格式（SampleFormat） 采样率（SampleRate) 声道数（Channel) 还以CD标准为例，量化格式 16bit，采样率 44100，声道数 2。 这里对声道概念做一个补充，平时所谓的双声道、单声道其实可以理解为需要记录几个信号，比如磁带，双声道就是同一时刻记录两个轨道的信息，一个负责记录左耳机振膜位置，一个负责记录右耳机振膜位置，以此类推，多个声道也是类似 上述信息就描述了CD的音质，对于声音格式来说，还有另一个概念用来描述它的大小，称为数据比特率（bitRate)，即 1s 内的比特数目，用于衡量音频数据单位时间内的容量大小，那么比特率如何计算？ $BitRate=SampleFormatSampleRateChannel $单位为千比特每秒kbps(kb per second)。比如对于CD音质，$44100162=1378.125kbps$那么，一分钟里，CD音质数据需要占多大存储空间呢？$1378.125*60/8/1024=10.09MB$ 所以一段1分钟的音频经过采样、量化、编码后可以得到一个大约10MB裸数据，成功地将音频的模拟信号转为数字信号，并存储下来。 音频压缩编码上面说到1分钟的CD音质数据的存储空间大于为 10MB，这对于光盘磁盘存储来说可接受，但对于网络传输肯定是无法接受的。所以就需要「压缩编码」出面解决问题 所谓音频编码主要指音频压缩技术，压缩通常又被分为有损和无损两种，但事实上，任何音频编码方式相对于最真实的自然声音信号，都是有损的压缩。从前面说到的采样、量化、编码中不难理解，我们把一条光滑的音频信号曲线分割成了许多数据块，然后对数据进行二进制编码，过程中其实就已经损失了一部分数据了，所以再次进行压缩也只能是尽可能的接近经过PCM编码后的音频裸数据。 图4-PCM编码 原图链接 既然压缩是为了减小编码后的数据存储空间，那么就应该去掉音频的“冗余信息”，从以下两个方面去衡量哪些数据是冗余的 之前提到过，人耳所能察觉的声音信号的频率范围为20Hz-20KHz，除此之外的其它频率人耳无法察觉，都可视为冗余信号 当一个强音频信号和一个弱音频信号同时存在时，弱信号会被强信号掩蔽，可视为冗余 其中第二点涉及另两个概念「频谱掩蔽效应」和「时域掩蔽效应」，名字看起来高深莫测，其实不难理解。 图5-频谱掩蔽效应 原图链接 「频谱掩蔽效应」一个音频信号被人耳听到是有一个阈值，阈值越小越容易被人听到，如图所示，虚线是随声音频率增大反应的阈值曲线，在 2-5kHz范围内，阈值很低，是人耳对声音最敏感的频率。现在假设有一个 60dB-0.2kHz 的强音信号出现时，阈值曲线会有所改变（图中实线部分），0.1-0.5kHz 频率的阈值被明显抬高，图中大概40dB-0.17kHz 左右的信号和 30dB-0.48kHz左右的信号都会被掩蔽。所以在0.1kHz-0.5kHz范围内，只能听到 65dp-0.2kHz 的声音，其余信号可视为冗余。 图6-时域掩蔽效应 原图链接 「时域掩蔽效应」是强信号和弱信号在时间维度发生的掩蔽，分为 前掩蔽，人在听到强信号之前，一些弱信号会被掩蔽 同时掩蔽，强信号会掩蔽同时发生的弱信号 后掩蔽，强信号消失后，需要经过一段时间后，才能重新听到弱信号 在这过程中被掩蔽的信号被视为冗余 几种音频压缩编码简介 编码 实现简介 特点 适用场景 WAV 无损压缩，其中一种实现方式是在 PCM 数据格式前加上 44 字节，分别描述采样率、声道数、数据格式等信息。 音质非常好，大量软件都支持 多媒体开发的中间文件、保存音乐和音效 MP3 具有不错的压缩比，使用 LAME 编码（MP3 编码格式的一种实现）的中高码率的 MP3 文件 音质在 128Kbit/s 以上表现还不错，压缩比比较高，大量软硬件都支持 高比特率下对兼容性有要求的音乐鉴赏 AAC 新一代有损压缩技术，通过一些附加的编码技术（PS、SBR 等），衍生出了 LC-AAC、HE-AAC、HE-AAC v2三种主要编码格式 小于 128Kbit/s 表现优异，多用于视频中的音频编码 128Kbit/s 一下的音频编码，多用于视频中的音频编码 Ogg 一种非常有潜力的编码，各种码率下都有比较优秀的表现，尤其是低码率场景下。可以在低码率的场景下仍然保持不错的音质，但目前软件硬件支持情况较差 可用比 MP3 更小的码率实现比 MP3 更好的音质，但兼容性不好 语音聊天的音频消息场景 1.压缩比，压缩后大小/原大小，通常小于 1，越小表示压缩的越狠2.“码率”是比特率是俗称3.表格总结于《音视频开发指南》，其中一些细节有兴趣的同学可以再深入查阅，本文不再深入研究 思考 为什么磁带、唱片逐渐消失在人们的视野里，音频播放器可以取而代之？ 声音是经过怎样的处理过程后保存成数字信息的？ 为什么要对音频数据进行压缩编码？ 参考链接 将模拟音频向数字音频的转换过程是怎样的？ 量化 (信号处理)) 雷骁骅-视频压缩编码和音频压缩编码的基本原理 雷骁骅-视音频编解码技术零基础学习方法 百度百科-PCM 编码 百度百科-音频编码 《音视频开发进阶指南-基于 Android 和 iOS 平台的实践》 - 第1章 音视频基础概念 转文声明如有文章转载需求，请注明本文作者以及链接，感谢各位理解支持","categories":[{"name":"Video","slug":"Video","permalink":"https://zzt.github.io/categories/Video/"}],"tags":[]},{"title":"初识比特币","slug":"bc-bitcoin-concept","date":"2022-01-22T17:01:56.000Z","updated":"2022-05-04T02:31:07.131Z","comments":true,"path":"2022/01/23/bc-bitcoin-concept/","link":"","permalink":"https://zzt.github.io/2022/01/23/bc-bitcoin-concept/","excerpt":"","text":"什么是比特币？ A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to another without going through a financial institution. 一个纯正的点对点去中心化的加密数字货币，应能够通过在线支付将币从一方直接发送到另一方，而无需通过任何中心金融机构。 比特币是一种加密货币（crypto-currency），实现自一个自称中本聪（Satoshi Nakamoto）的不明身份的人所发表的一篇论文（比特币白皮书） 与其说比特币是一种加密货币，不如说比特币是一种基于 P2P 网络的支付结算系统，这样更易于大家理解其本质。 为什么要发明比特币？中心化，基于信任模型 酒花 App 平台买了两瓶精酿啤酒一个自称三方供应商的人加我微信，告知我其中一瓶酒没货了，可以加钱换其他的酒虽然这个人微信朋友圈都是精酿啤酒相关的内容，且明确知道我买的哪个酒没货了但是，我内心还是不信任这个人，更信任平台，于是我还是在平台换了一瓶酒 平台就真的值得信任么？假如我下单的时候正好赶上平台服务器宕机，扣款成功了，但没收到货。由于平台系统做的不好，再也找不到那笔订单，不能证明我付过钱，也不能给我发货。这笔交易就没有人能说的清楚了，信任也就不存在了。 比特币要去解决信任问题 What is needed is an electronic payment system based on cryptographic proof instead of trust, allowing any two willing parties to transact directly with each other without the need for a trusted third party. 我们真正需要的是一种基于加密算法密码学原理而非基于信任的数字货币支付系统，不需要可信任第三方参与的情况下，允许双方直接进行支付交易 双花攻击（Double Spending Attack)「双花」即同一笔钱花了两次或多次。 假设央行发行了一款数字货币，货币在软件中其实就是文件，完全可以复制。假如 A 在转给 B 100 元后，又复制了同一笔钱转给了 C，就是所谓的「双花」，双花攻击只通过验证数字货币的签名是不够的，还需要使用额外的手段。 比特币要去解决双花问题 We propose a solution to the double-spending problem using a peer-to-peer network 我们将在本文提出一种新方案，使用点对点去中心化网络去解决这个双花问题 在比特币交易小节中，会详细解释比特币是如何解决双花问题的。 比特币中的密码学哈希算法（Hash Algorithm)哈希算法是用来做什么的呢？我们先来看一个小故事。 雍正到底是不是篡位登基的？ 一直有一个传说称雍正不是康熙真正传位的皇帝，而是有人偷偷修改了遗诏，篡位登基的。 假如康熙知道哈希函数 如果没有哈希函数，在康熙皇帝驾崩后，遗诏是死无对证，只能遗诏写什么，大臣就做什么。 但有了哈希函数后就变得不一样了，康熙可以在活着的时候就可以提前写好遗诏，并用哈希函数计算出一个哈希串，交予大臣们。大臣们看到哈希串也不能猜出遗诏的内容到底是什么，只能等到遗诏公布的那天，再去计算一次哈希值，看与当初皇帝给的哈希串是否一致，来判断遗诏是否被人篡改了。如果修改了，就不会遵诏行事。 通过这个小故事，可以简单总结出哈希的两个性质： 防篡改，输入稍有改动，输出千差万别 输出结果不可逆，只知道结果不能反推出输入是什么 比特币使用的哈希算法SHA256（Security Hash Algorithm），是一种密码哈希函数（Cryptographic Hash Function）。 $任意输入 ==&gt; SHA256 ==&gt; 256位哈希$ 在比特币中，利用了SHA256的三个性质 不可逆（Hiding） 抗哈希碰撞（Collision .istance） 哈希值不可预测（Puzzle friendly） 不可逆（Hiding）SHA256的特性： 输入长度任意 输出长度固定，256bit 比如 $全世界的图书 ==&gt; SHA256 ==&gt; 256 位哈希$ 如果这个过程可逆的话，我们就发现了一种无敌的压缩算法，可以把全世界的图书压成 256 位，再进行存储。 抗哈希碰撞（Collision .istance）根据抽屉原理，输入空间无限，输出空间有限，理论上一定会存在碰撞。 但是，从长期经验看，没有什么人为的、高效的方式制造碰撞。 只能通过暴力遍历输入空间的方式来寻找碰撞 哈希值不可预测（Puzzle friendly）Puzzle Friendly，直译为谜题友好性，是指事先给定一个哈希串，比如 00000000feacb46d… ，前 8 位都是 0，让你解谜题找到输入是什么。 由于 SHA256 没有直接办法或通过找到一定规律来猜出输入是什么，只能通过暴力遍历输入空间的方式来找到答案。（其实一点都不友好） 比如你找到一个输入 a，输出的前 7 位都是 0，感觉再简单调整一下输入就能找到答案了，其实不是的，修改输入后可能得到的答案一个 0 都没有。也就是说你的每一次计算是无记忆性的（Memoryless），只能通过大量地尝试，不断的寻找答案。 除此之外，找到答案后，其他人验证答案却很简单，只需要把你的答案再用哈希函数计算一次即可。（difficult to solve, but easy to verify） 比特币挖矿过程充分利用了 Puzzle friendly，后面我们会详细说明。 数字签名（Digital Signature）了解数字签名之前，需要先对非对称加密有一定认识。 什么是非对称加密？ Alice 想通过非对称加密的方式发送一条消息给 Bob，他要怎么做呢？ Bob 需要先生成公钥私钥对（public key, private key） Bob 的公钥是对所有人公开的，所以 Alice 可以拿到 Bob’s public key Alice 使用 Bob’s public key 对 Message 加密，并将密文通过网络传输给 Bob Bob 接收到密文后，使用自己的私钥 Bob’s private key 解密，得到了 Message 完成通信 由于 Bob’s private key 是保存在 Bob 手里的，只要私钥不泄露，就是安全的。 3.3.2、什么是数字签名？还是 Alice 想要给 Bob 发送一条消息，并采用非对称加密的方式，Alice 凭什么相信 Bob 的公钥就是 Bob 的呢？有没有可能被其他人调包了呢？这就需要 Alice 用到数字签名的技术，来验证 Bob 的身份是否真实 Bob 用私钥生成数字签名 Alice 用 Bob 的公钥验证签名 如果验证通过，则证明公钥一定是 Bob 的，因为签名只能由 Bob 的私钥生成 四、比特币是如何交易的？4.1、区块链在比特币系统中，交易是存在区块里的，那么区块链到底是什么呢？ 一个区块是由 block header 和 block body 组成 block header 中会存储前一个区块头的哈希值 block body 中会存储具体的交易信息（Transaction 简写为 Tx) 区块链其实不是区块组成的链表结构，而是通过 (key,value) 数据库实现的。在数据库中，key 是区块头的哈希值，value 是区块内容。 账户在比特币中，账户就是由本机生成的公私钥对 公钥的哈希值用作转账地址，相当于银行卡号 私钥相当于银行密码，需要自己妥善保管，一旦丢失是无法找回的 防止双花现实中，A -&gt; B 100元人民币的过程实际是 A 的钱包减少 100元，B 的钱包增加 100元，天然能防止「双花」（除非你把花出去的钱偷回来再花一次）。 但是，比特币中没有账户系统，不会帮你记录用户的账户中余额还有多少。那么，比特币是如何验证「双花」的呢？ 回溯币源比特币的每笔交易由未花费的输出（UTXO Unspenting Transaction Output），本次交易的输入拼接而成。每笔交易会去验证 UTXO 是否能支付足量的币，具体可以看下面的例子。 coinbase 称作「铸币」交易，是矿工挖出新区块获得的出块奖励，假设是 A 获得了出块奖励的 10 BTC A 转给了 B 5 BTC，同时转给了 C 5 BTC，这时系统会去验证 A 有没有能力支付 10 BTC，会向前回溯找到 A BTC 的来源，于是找到了铸币交易，发现有 10 BTC，交易合法 同理 C 在转给 E 7BTC 时，需要找到之前交易中得到的 5 + 2 BTC 转账者除了要证明币源，还需要将交易用自己的私钥签名，用于身份验证。 比特币挖矿为什么要挖矿？ 产生比特币，只有挖出新的区块，才会产生新的比特币。中本聪规定，最初出块奖励为 50 BTC，每隔 4 年出块奖励减半，所以比特币总量大概为 2100 万个 打包交易，通过挖出新区块，打包记录新产生的交易 达成共识，通过工作量证明（Proof of Work）+ 奖励机制，让系统中的节点达成共识，向好的方向发展 挖矿的过程 比特币挖矿的过程和实际挖金矿的过程很像： 金子的总量是有限的，越挖会越少，比特币也是如此 挖金子需要付出科技成本和体力劳动后才能得到回报，比特币也是需要付出算力、电力成本，才能收获比特币 下面我们来简单了解一下，比特币挖矿的过程是怎样的。 找到最长合法链在比特币中的矿工指的是系统中的全节点，除了挖矿，还要负责维护全量的区块数据 诚实的矿工会按照最长合法链规则挖矿 最长，顾名思义，矿工只沿着系统中最长的链向后挖 合法，验证区块信息是否被篡改，区块中记录的所有的交易是否合法。一旦矿工识别当前链不合规，便会马上找到另外的最长合法链，继续挖矿 挖矿解谜简单说，挖矿解谜就是矿工通过暴力哈希运算，找到符合要求的随机数 nonce，满足下面的公式 $H(header || nonce) &lt;= target$ target 是一串 256 位的哈希（前 k 位都是 0） k 越大，target 越小，挖矿难度越高。就像打靶子一样，k 越大，表示靶子越小，越难命中 增加算力，会增加挖到矿的概率，但不代表当前区块一定会被算力高的矿工挖到 中本聪设计出块时间在10分钟左右，每两周调整一次挖矿难度。比如上两周平均出块时间为 7 分钟，则会增大难度，否则会降低难度。 广播解谜成功后，需要迅速把组装好的区块向相邻节点广播，让自己挖的区块在最长合法链中得到确认，拿到出块奖励和交易手续费。 6次交易确认机制 网络是不可靠的，在广播阶段很有可能出现延时。所以交易上链后，并不是马上就生效的，中本聪设计了一个区块上链后需要再等 6 个区块上链后才能被真正确认。 为什么要这样做？ 防止双花，假如甲、乙矿工同时挖到了新区块，并且广播了出去。其中甲记录 A 转给 B 10BTC，乙记录了 A 转给 C 10BTC，事实上 A 只有 10BTC，如果两个区块都被认可，那就出现了双花。 为什么是 6 次？中本聪认为，6 个区块大概要花费一个小时才能挖出来，想要再做一次分叉攻击篡改，是需要较大成本的。 51%算力攻击 假设有某个组织拥有了全世界 51% 的算力，并且一直在沿着自己的链挖矿，理论上某个时间点，这个组织所挖的链就会变成最长的，广播后，这条链就会成为最长合法链，那么以前的交易就会被这个组织替换。 51% 攻击只能将合法的交易替换上链，但是无法偷其他用户的比特币，因为诚实的节点会验证交易的签名。 51% 攻击是可以发动双花攻击的，由于算力强大，会导致 6 次确认机制失效。比如 A =&gt; B (10BTC) 已经得到确认，其中 A 是攻击者，交易是 A 的签名，发动 51% 攻击后，完全可以修改为 A =&gt; C (10BTC)，C 可以是攻击者的另一个账户。 51% 只是一个象征性的数字，并不一定算力一定要达到 51 才能攻击，有研究小组表明只要拥有 30% 的全网算力，就足以发动 51% 攻击。（为什么只需要30%？个人猜测是，其他算力之间还存在竞争关系，而这30%是团结一致的） 曾有矿池（GHash.IO）算力超过了 51%，一度引起比特币价值暴跌，之后很多矿工自觉退出了矿池，来保证系统的安全。 比特币系统在「安全性」「高价值」「健康挖矿」三个方面已经形成闭环。算力越高，想发动 51% 攻击就越困难，系统就越安全，随之比特币价格就会越高。使得想要发动攻击的人即使发动了攻击也不一定能赚到什么，还不如用所有算力稳稳挖矿收益高。 比特币的缺点 工作量证明机制造成算力、电力的浪费 出块时间限定平均10分钟左右，一笔交易需要大概需要1小时才能得被系统确认 比特币私钥丢失之后，是没办法找回的，账户中的比特币永远都取不出来了 转账写错地址，无法回滚 参考 《零基础学区块链》 北京大学肖臻老师的公开课 比特币白皮书 《图说区块链》 《图解密码技术》","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"https://zzt.github.io/categories/BlockChain/"}],"tags":[]},{"title":"Kotlin 协程的创建过程","slug":"kt-coroutine-create","date":"2022-01-22T16:55:34.000Z","updated":"2022-05-04T02:31:07.148Z","comments":true,"path":"2022/01/23/kt-coroutine-create/","link":"","permalink":"https://zzt.github.io/2022/01/23/kt-coroutine-create/","excerpt":"","text":"创建并启动协程123456789101112131415161718fun create.main() &#123; //1. 创建协程体 val coroutine = suspend &#123; println(&quot;in coroutine&quot;) 5 &#125;.createCoroutine(object: Continuation&lt;Int&gt; &#123; override fun resumeWith(result: Result&lt;Int&gt;) &#123; println(&quot;coroutine end: $result&quot;) &#125; override val context: CoroutineContext get() = EmptyCoroutineContext &#125;) //2. 执行协程 coroutine.resume(Unit)&#125; 上面代码的输出结果：12in coroutinecoroutine end: Success(5) 协程的执行过程 调用栈流程如下 我们通过 suspend block#createCoroutine 得到的 coroutine 实际是 SafeContinuation 对象 SafeContinuation 实际上是代理类，其中的 delegate 属性才是真正的 Continuation 对象 suspend block 中的代码在 BaseContinuationImpl 中执行 我们的匿名内部类对象 Continuation 被回调 suspend block 是如何变为协程体被执行的？我们分析调用栈得知，resumeWith 最终是在 BaseContinuationImpl 中执行的，下面来看看代码 123456789101112131415161718192021222324252627282930313233@SinceKotlin(&quot;1.3&quot;)internal abstract class BaseContinuationImpl( public val completion: Continuation&lt;Any?&gt;?) : Continuation&lt;Any?&gt;, CoroutineStackFrame, Serializable &#123; public final override fun resumeWith(result: Result&lt;Any?&gt;) &#123; var current = this var param = result while (true) &#123; probeCoroutineResumed(current) with(current) &#123; val completion = completion!! val outcome: Result&lt;Any?&gt; = try &#123; val outcome = invokeSuspend(param) //1.这里执行了 suspend block if (outcome === COROUTINE_SUSPENDED) return Result.success(outcome) &#125; catch (exception: Throwable) &#123; Result.failure(exception) &#125; releaseIntercepted() if (completion is BaseContinuationImpl) &#123; current = completion param = outcome &#125; else &#123; completion.resumeWith(outcome) //2.这里回调了我们的匿名内部类 return &#125; &#125; &#125; &#125; protected abstract fun invokeSuspend(result: Result&lt;Any?&gt;): Any? //3. 抽象方法&#125; 在代码注释 1. 处，调用 current.invokeSuspend，执行了我们定义的协程体，证明 suspend block 其实是 BaseContinuationImpl 的子类 在 2. 处，协程体执行完毕后，我们的代码收到了完成回调 在 3. 处，可以发现 invokeSuspend 是个抽象方法，suspend block 就是这个方法的具体实现 下面我通过断点，进一步分析 suspend block 是通过哪个子类执行的。 可以看到 current 是名为 {文件}${方法}${变量}$1 格式的对象，证明 kotlin 编译器遇到 suspend 关键字后会帮我们生成一个 BaseContinuationImpl 的子类 那么，这个子类到底是什么呢？将 kt 编译为 .class 再通过 jadx 打开后，得到的 java 代码如下 12345678public final class CreateCoroutineKt &#123; public static final void create.main() &#123; Continuation coroutine = ContinuationKt.createCoroutine(new CreateCoroutineKt$create.main$coroutine$1(null), new CreateCoroutineKt$create.main$coroutine$2()); Unit unit = Unit.INSTANCE; Result.Companion companion = Result.Companion; coroutine.resumeWith(Result.constructor-impl(unit)); &#125;&#125; 123456789101112131415161718192021222324252627282930final class CreateCoroutineKt$create.main$coroutine$1 extends SuspendLambda implements Function1&lt;Continuation&lt;? super Integer&gt;, Object&gt; &#123; int label; CreateCoroutineKt$create.main$coroutine$1(Continuation&lt;? super CreateCoroutineKt$create.main$coroutine$1&gt; continuation) &#123; super(1, continuation); &#125; @NotNull public final Continuation&lt;Unit&gt; create(@NotNull Continuation&lt;?&gt; continuation) &#123; return new CreateCoroutineKt$create.main$coroutine$1(continuation); &#125; @Nullable public final Object invoke(@Nullable Continuation&lt;? super Integer&gt; continuation) &#123; return create(continuation).invokeSuspend(Unit.INSTANCE); &#125; @Nullable public final Object invokeSuspend(@NotNull Object obj) &#123; IntrinsicsKt.getCOROUTINE_SUSPENDED(); switch (this.label) &#123; case 0: ResultKt.throwOnFailure(obj); System.out.println((Object) &quot;in coroutine&quot;); //协程体的逻辑 return Boxing.boxInt(5); default: throw new IllegalStateException(&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;); &#125; &#125;&#125; 明显看出，kt 编译器帮助我们把 suspend 关键字变为了 SuspendLambda 的 子类，并重写了 invokeSuspend 方法，不难猜出 SuspendLambda 继承自 BaseContinuationImp 总结用一个类图简单的总结一个协程创建并执行的过程。 suspend block(lambda) 在编译时会转变为 SuspendLambda 的匿名子类，并把 block 中的逻辑通过重写 invokeSuspend 实现 调用 suspend_lambda.createCoroutine 会得到 SafeContinuation 对象，这只是一个代理类，代理的对象正是我们传入的 SuspendLambda createCoroutine 的参数是 completion，代表协程执行完毕的回调 最终调用到了 BaseContinuationImpl 的 resumeWith，完成协程的调用，调用完毕的回调","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://zzt.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin协程","slug":"Kotlin协程","permalink":"https://zzt.github.io/tags/Kotlin%E5%8D%8F%E7%A8%8B/"}]},{"title":"Kotlin Sequence 原理","slug":"kt-sequence","date":"2022-01-22T14:01:56.000Z","updated":"2022-05-04T02:31:07.159Z","comments":true,"path":"2022/01/22/kt-sequence/","link":"","permalink":"https://zzt.github.io/2022/01/22/kt-sequence/","excerpt":"","text":"一、Sequence 和 List 的区别以下内容出自官方示例 1. List123456789fun list() &#123; val words = &quot;The quick brown fox jumps over the lazy dog&quot;.split(&quot; &quot;) val wordList = words.toList() val lengthList = wordList.filter&#123; println(&quot;filter $it&quot;); it.length &gt; 3&#125; .map &#123; println(&quot;map $&#123;it.length&#125;&quot;); it.length &#125; .take(4) println(&quot;Lengths of first 4 words longer than 3 chars&quot;) println(lengthList)&#125; 运行结果如下12345678910111213141516filter Thefilter quickfilter brownfilter foxfilter jumpsfilter overfilter thefilter lazyfilter dogmap 5map 5map 5map 4map 4Lengths of first 4 words longer than 3 chars[5, 5, 5, 4]运行过程 2. Sequence1234567891011121314151617fun sequence() &#123; val words = &quot;The quick brown fox jumps over the lazy dog&quot;.split(&quot; &quot;) val wordSeq = words.asSequence() val lengthSeq = wordSeq .filter &#123; println(&quot;filter $it&quot;) it.length &gt; 3 &#125; .map &#123; println(&quot;map $&#123;it.length&#125;&quot;) it.length &#125; .take(4) println(&quot;Lengths of first 4 words longer than 3 chars&quot;) println(lengthSeq.toList())&#125; 运行结果如下123456789101112Lengths of first 4 words longer than 3 charsfilter Thefilter quickmap 5filter brownmap 5filter foxfilter jumpsmap 5filter overmap 4[5, 5, 5, 4]运行过程 3. 区别 直观来看，sequence 执行的步骤少于 list list 的操作符会立即执行，sequence 的操作符可以理解为先声明，后面执行 toList 的时候才会触发 list filter 操作符处理了全量数据，然后 map 映射 filter 之后的所有数据，sequence 则是每条数据经过 filter -&gt; map 流水线处理，不合格的数据不会向后执行 二、Sequence 原理下面我们具体看看 为什么 sequence 能做到先声明，后触发 为什么 sequence 能实现流水线的效果，避免操作浪费 下面的图描述了，声明操作符到触发流程的过程，我们逐一剖析每一步都做了什么 我们按照代码真正执行的顺序来分析，有助于理解，执行顺序正和我们声明操作的顺序相反 take &amp; toList最后的操作符是 take(4)，然后将其转为了 List。首先来看看 take1234567891011121314151617181920212223242526272829303132333435363738//take(4) 操作符其实对应的会生成一个 TakeSequence 对象public fun &lt;T&gt; Sequence&lt;T&gt;.take(n: Int): Sequence&lt;T&gt; &#123; require(n &gt;= 0) &#123; &quot;Requested element count $n is less than zero.&quot; &#125; return when &#123; n == 0 -&gt; emptySequence() this is DropTakeSequence -&gt; this.take(n) else -&gt; TakeSequence(this, n) &#125;&#125;internal class TakeSequence&lt;T&gt;( private val sequence: Sequence&lt;T&gt;, //传入了上一个Sequence，也就是 map 对应的 Sequence private val count: Int) : Sequence&lt;T&gt;, DropTakeSequence&lt;T&gt; &#123; init &#123; require(count &gt;= 0) &#123; &quot;count must be non-negative, but was $count.&quot; &#125; &#125; override fun drop(n: Int): Sequence&lt;T&gt; = if (n &gt;= count) emptySequence() else SubSequence(sequence, n, count) override fun take(n: Int): Sequence&lt;T&gt; = if (n &gt;= count) this else TakeSequence(sequence, n) override fun iterator(): Iterator&lt;T&gt; = object : Iterator&lt;T&gt; &#123; var left = count val iterator = sequence.iterator() //map 对应的 Sequence 的 iterator override fun next(): T &#123; if (left == 0) throw NoSuchElementException() left-- return iterator.next() &#125; override fun hasNext(): Boolean &#123; //通过 left，决定取 list 中的前几个数据 return left &gt; 0 &amp;&amp; iterator.hasNext() //看上一个 iterator 中是否有数据 &#125; &#125;&#125;代码中的注释已经详细解释了逻辑，其中重点是： 操作符会对应一个 Sequence 对象去处理迭代逻辑 TakeSequence 在构造的时候，传入了上一个 Sequence 对象 TakeSequence 的 hasNext 返回什么取决于上一个 iterator 的 hasNext 下面来看看 toList 做了什么12345678910public fun &lt;T&gt; Sequence&lt;T&gt;.toList(): List&lt;T&gt; &#123; return this.toMutableList().optimizeReadOnlyList()&#125;public fun &lt;T, C : MutableCollection&lt;in T&gt;&gt; Sequence&lt;T&gt;.toCollection(destination: C): C &#123; for (item in this) &#123; destination.add(item) &#125; return destination&#125;optimizeReadOnlyList 只是做了一次类型转换，将 mutable 转为 immutable。toMutableList 最终会调用到 toCollection，这里面就正式开始了 iterator 的逻辑，也就是走到了 TakeSequence 里面的迭代逻辑。 从 TakeSequence 迭代逻辑里知道，它会继续调用上一个 Sequence 的迭代器逻辑，所以，我们大致能猜出，Sequence 是通过类似责任链的方式，完成了流水线操作，我们继续分析。 map123456789101112131415161718192021222324public fun &lt;T, R&gt; Sequence&lt;T&gt;.map(transform: (T) -&gt; R): Sequence&lt;R&gt; &#123; return TransformingSequence(this, transform)&#125;internal class TransformingSequence&lt;T, R&gt;constructor( private val sequence: Sequence&lt;T&gt;, //传入了上一个 Sequence，filter 对应的 Sequence private val transformer: (T) -&gt; R) : Sequence&lt;R&gt; &#123; override fun iterator(): Iterator&lt;R&gt; = object : Iterator&lt;R&gt; &#123; val iterator = sequence.iterator() override fun next(): R &#123; return transformer(iterator.next())//这里调用我们的 map 逻辑 &#125; override fun hasNext(): Boolean &#123; return iterator.hasNext() //调用了上一个 iterator 的 hasNext &#125; &#125; internal fun &lt;E&gt; flatten(iterator: (R) -&gt; Iterator&lt;E&gt;): Sequence&lt;E&gt; &#123; return FlatteningSequence&lt;T, R, E&gt;(sequence, transformer, iterator) &#125;&#125; 果不其然，map 对应的 Sequence 是 TransformingSequence，并且迭代过程仍然会先调用上一个 Sequence 的 iterator，这基本印证了我们的猜想，继续分析。 filter123456789101112131415161718192021222324252627282930313233343536373839404142434445public fun &lt;T&gt; Sequence&lt;T&gt;.filter(predicate: (T) -&gt; Boolean): Sequence&lt;T&gt; &#123; return FilteringSequence(this, true, predicate)&#125;internal class FilteringSequence&lt;T&gt;( private val sequence: Sequence&lt;T&gt;,//传入上一个 Sequence，asSequence private val sendWhen: Boolean = true, private val predicate: (T) -&gt; Boolean) : Sequence&lt;T&gt; &#123; override fun iterator(): Iterator&lt;T&gt; = object : Iterator&lt;T&gt; &#123; val iterator = sequence.iterator() //上一个 Sequence 的 iterator var nextState: Int = -1 var nextItem: T? = null private fun calcNext() &#123; while (iterator.hasNext()) &#123;//上一个 iterator 是否有数据 val item = iterator.next() if (predicate(item) == sendWhen) &#123;//这里调用了我们的过滤逻辑 nextItem = item nextState = 1 return &#125; &#125; nextState = 0 &#125; override fun next(): T &#123; if (nextState == -1) calcNext() if (nextState == 0) throw NoSuchElementException() val result = nextItem nextItem = null nextState = -1 @Suppress(&quot;UNCHECKED_CAST&quot;) return result as T &#125; override fun hasNext(): Boolean &#123; if (nextState == -1) calcNext() return nextState == 1 &#125; &#125;&#125; 除了过滤逻辑和 map 不一致，其他是一样的。 asSequence12345678public fun &lt;T&gt; Iterable&lt;T&gt;.asSequence(): Sequence&lt;T&gt; &#123; return Sequence &#123; this.iterator() &#125;&#125;@kotlin.internal.InlineOnlypublic inline fun &lt;T&gt; Sequence(crossinline iterator: () -&gt; Iterator&lt;T&gt;): Sequence&lt;T&gt; = object : Sequence&lt;T&gt; &#123; override fun iterator(): Iterator&lt;T&gt; = iterator()&#125; 源码比较简单，就是 new 了一个 Sequence 的匿名对象，并且将 list 的 iterator 作为参数传了进去。所以，流水线最后调用的是 list 的 iterator。 三、总结 再看开始的流程图，回答提出的两个问题 1.为什么 sequence 能做到先声明，后触发因为操作符并不会触发迭代逻辑，只有最后的 toList 才会真正触发 2.为什么 sequence 能实现流水线的效果，避免操作浪费因为我们在声明操作符的时候，将 Sequence 对象组装了成了一个链，迭代的时候会从最后一个声明的 iterator 递归地调到第一个声明的 iterator，保证执行顺序是我们声明的顺序。并且，如果迭代的某一环不满足条件，就不会继续走到下一个迭代里，也就避免了操作的浪费。 如需转载，请注明原文出处，谢谢！","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://zzt.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin基础","slug":"Kotlin基础","permalink":"https://zzt.github.io/tags/Kotlin%E5%9F%BA%E7%A1%80/"}]},{"title":"Kotlin Lambda 函数中的 Receiver 是什么？","slug":"kt-receiver","date":"2022-01-22T13:31:48.000Z","updated":"2022-05-04T02:31:07.151Z","comments":true,"path":"2022/01/22/kt-receiver/","link":"","permalink":"https://zzt.github.io/2022/01/22/kt-receiver/","excerpt":"","text":"一、示例代码先来看一段示例代码，初步了解 Receiver 是什么 123456789101112131415import java.lang.StringBuilderfun main() &#123; println(&quot;&quot;.buildString &#123; this.append(&quot;a&quot;) append(&quot;b&quot;) append(&quot;c&quot;) &#125;)&#125;fun String.buildString(action: StringBuilder.() -&gt; Unit): String &#123; val sb = StringBuilder() sb.action() return sb.toString()&#125; 上述代码可以为 String 增加一个扩展函数 buildString，可以直接在 buildString {} 作用域中使用 StringBuilder 的 append 或其他方法，省去了我们自己 new StringBuilder 的过程 下面是对代码的详细解释 形如 T.() -&gt; R 的函数，就是 Receiver 类型 需要通过调用 [T的对象].() 的方式，来把 [T的对象] 作为 this 传到 lambda 作用域中 调用扩展函数时，可以显式用 this 访问传进来的对象 也可隐式调用 二、上述代码翻译成 java 是什么样的？通过 jadx 工具将 class 转为 java后，代码如下 main 方法中原本的 lambda 被转为了 buildString(&quot;&quot;, ReceiverKt$main$1.INSTANCE)，ReceiverKt$main$1 是什么我们稍后分析 buildString 方法接收了一个 Function1 类型的对象，证明 ReceiverKt$main$1 是 kt 帮我们生成的并且实现了 Function1 buildString 内部逻辑就是创建了一个 StringBuilder，然后调用 function1.invoke(sb) 下面来看看 ReceiverKt$main$1 是什么 很简单，就是通过 invoke 调用我们 buildString lambda 里的内容 三、另一个代码示例下面我们来看一段和上面例子很像的代码12345678910111213fun main() &#123; println(&quot;&quot;.buildString_ &#123;sb: StringBuilder -&gt; sb.append(&quot;d&quot;) sb.append(&quot;e&quot;) sb.append(&quot;f&quot;) &#125;)&#125;fun String.buildString_(action: (stringbuilder: StringBuilder) -&gt; Unit): String &#123; val sb = StringBuilder() action(sb) return sb.toString()&#125;和第一段代码的区别是 buildString 参数变为了 (StringBuilder) -&gt; Unit，我们将 StringBuilder 对象作为 lambda 的参数传入了 调用的地方需要使用 it 或者自己定义一个参数名来使用 StringBuilder 对象 这段代码转为 Java 后是什么样的呢？ 可以看到使用 Receiver 的方式和使用给 lambda 函数定义参数的方式转为 Java 代码后只是在 invoke 参数的变量名有区别，仅此而已。 四、小结 定义 lambda Receiver，调用方可以在 lambda 作用域中使用 this 访问 Receiver 对象 定义 lambda 带参函数，调用方可以在 lambda 作用域中自己定义对象变量名或者使用默认的 it 上述两种方式转为 Java 并没有什么本质区别，只是变量名上的不同 五、kotlin 标准库里的操作符哪些用到了 Receiver？在了解 Receiver 的原理后，可以让我们更好地理解 kotlin 标准库里的操作符 1.apply12345678@kotlin.internal.InlineOnlypublic inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123; contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125; block() return this&#125; 使用 apply 后，我们可以在 lambda 使用 this，比如1234val str = &quot;abc&quot;str.apply &#123; println(this.length)&#125; 2.with1234567@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R &#123; contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125; return receiver.block()&#125; with 和 apply 的区别是，需要把 receiver 显示地传给 with，比如 1234val str = &quot;abc&quot;with(str) &#123; println(this.length)&#125; 如需转载，请注明原文出处，谢谢！","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://zzt.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin基础","slug":"Kotlin基础","permalink":"https://zzt.github.io/tags/Kotlin%E5%9F%BA%E7%A1%80/"}]}],"categories":[{"name":"Windows","slug":"Windows","permalink":"https://zzt.github.io/categories/Windows/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://zzt.github.io/categories/Kotlin/"},{"name":"考研","slug":"考研","permalink":"https://zzt.github.io/categories/%E8%80%83%E7%A0%94/"},{"name":"Video","slug":"Video","permalink":"https://zzt.github.io/categories/Video/"},{"name":"BlockChain","slug":"BlockChain","permalink":"https://zzt.github.io/categories/BlockChain/"}],"tags":[{"name":"Kotlin Compiler","slug":"Kotlin-Compiler","permalink":"https://zzt.github.io/tags/Kotlin-Compiler/"},{"name":"高数","slug":"高数","permalink":"https://zzt.github.io/tags/%E9%AB%98%E6%95%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"https://zzt.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Kotlin协程","slug":"Kotlin协程","permalink":"https://zzt.github.io/tags/Kotlin%E5%8D%8F%E7%A8%8B/"},{"name":"Kotlin基础","slug":"Kotlin基础","permalink":"https://zzt.github.io/tags/Kotlin%E5%9F%BA%E7%A1%80/"}]}